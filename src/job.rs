use std::{collections::HashMap, path::PathBuf};

use owo_colors::OwoColorize;

use crate::{
    codegen::codegen_stylesheet, compile::fill_holes, css::StyleSheet, css_component_scoping::scope_css_to_component, parse::parse_full, utils::children_of, Component, Node
};

pub struct Job {
    pub path: PathBuf,
    pub output: PathBuf,
}

impl Job {
    pub fn run(&self) {
        match compile(self) {
            Ok(_) => {}
            Err(err) => println!("{}: {}", "ERR".red(), err),
        }
    }
}

fn compile(job: &Job) -> Result<(), String> {
    let files = list_files(&job.path).map_err(|e| e.to_string())?;

    let mut components_map = HashMap::new();

    let mut stylesheet = vec![];

    for path in files {
        let component = load_componet(path).map_err(|e| e.to_string())?;
       
        let (styles, component) = collect_css(component);
        
        let (styles, component) = scope_css_to_component(component, styles);

        stylesheet.extend(styles);

        components_map.insert(component.name.clone(), component);
    }

    let root = components_map
        .get("Root")
        .ok_or("No root component found.".to_string())?
        .clone();

    let mut root_node = Node::Component(root.clone());

    fill_holes(&mut root_node, &components_map).map_err(|e| e.to_string())?;

    let code = format!(
        "<!DOCTYPE html>
<!-- This file was generated by Lilac v{}. -->
<script>{}</script>
<style>{}{}</style>
{}",
        env!("CARGO_PKG_VERSION"),
        include_str!("../prelude.js"),
        get_root_css(&job.path)?,
        codegen_stylesheet(&stylesheet),
        root_node.full_codegen()
    );

    // println!("{}", code);

    write_file(&job.output, &code).map_err(|e| e.to_string())?;

    Ok(())
}

fn load_file(path: &PathBuf) -> Result<String, std::io::Error> {
    std::fs::read_to_string(path)
}

fn write_file(path: &PathBuf, contents: &str) -> Result<(), std::io::Error> {
    std::fs::write(path, contents)
}

fn list_files(path: &PathBuf) -> Result<Vec<PathBuf>, std::io::Error> {
    let mut files = vec![];

    for entry in std::fs::read_dir(path)? {
        let entry = entry?;
        let path = entry.path();
        if path.extension().map_or(false, |e| e == "lilac") {
            files.push(path.clone());
        }

        if path.is_dir() {
            files.extend(list_files(&path)?);
        }
    }

    Ok(files)
}

fn get_root_css(path: &PathBuf) -> Result<String, String> {
    let path = path.join("root.css");

    if path.exists() {
        load_file(&path).map_err(|_| "Unable to root.css.".to_string())
    } else {
        Ok("".to_string())
    }
}

fn collect_css(mut component: Component) -> (StyleSheet, Component) {
    let mut node = Node::Component(component.clone());
    let styles = _collect_css(&mut node);
    let component = match node {
        Node::Component(c) => c,
        _ => unreachable!(),
    };
    (styles, component)
}

fn _collect_css(node: &mut Node) -> StyleSheet {
    let mut ss = vec![];

    if let Node::StyleTag(css) = node {
        ss.extend(css.clone());
    }

    if let Some(children) = children_of(node) {
        for i in (0..children.len()).rev() {
            let node = &mut children[i];
            ss.extend(_collect_css(node));
            if let Node::StyleTag(_) = node {
                children.remove(i);
            }
        }
    }

    ss
}

fn load_componet(path: PathBuf) -> Result<Component, String> {
    let contents = load_file(&path).map_err(|_| "Unable to load file.".to_string())?;

    let name = path.file_stem().unwrap().to_str().unwrap();

    parse_full(&contents, name).map_err(|err| err.format(&contents))
}
